//
//  BaseTextField.swift
//  GIFT_APP
//
//  Created by Alguz on 11/24/19.
//  Copyright Â© 2019 Leo Suzin. All rights reserved.
//

import Foundation
import UIKit

@IBDesignable class BaseTextField: TextFieldValidator {
    override init(frame: CGRect) {
        super.init(frame: frame)
        setupViews()
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        setupViews()
    }
    
    func setupViews() {
        self.borderStyle = .none
        self.textInputView.backgroundColor = textViewBg
        updateView()
    }
    
    /// When positive, the background of the layer will be drawn with rounded corners. Also effects the mask generated by the `masksToBounds' property. Defaults to zero. Animatable.
    @IBInspectable var cornerRadius: Double {
        get {
            return Double(self.layer.cornerRadius)
        }
        set {
            self.layer.cornerRadius = CGFloat(newValue)
        }
    }
    
    @IBInspectable var topLeft: Bool = true {
        didSet {
            updateCorners()
        }
    }

    @IBInspectable var topRight: Bool = true {
        didSet {
            updateCorners()
        }
    }

    @IBInspectable var bottomLeft: Bool = true {
        didSet {
            updateCorners()
        }
    }

    @IBInspectable var bottomRight: Bool = true {
        didSet {
            updateCorners()
        }
    }
    
    private func updateCorners() {
        var masks = CACornerMask()
        if topLeft {
            masks.insert(.layerMinXMinYCorner)
        }
        if topRight {
            masks.insert(.layerMaxXMinYCorner)
        }
        if bottomLeft {
            masks.insert(.layerMinXMaxYCorner)
        }
        if bottomRight {
            masks.insert(.layerMaxXMaxYCorner)
        }
        layer.maskedCorners = masks
    }
    
    
    /// The width of the layer's border, inset from the layer bounds. The border is composited above the layer's content and sublayers and includes the effects of the `cornerRadius' property. Defaults to zero. Animatable.
    @IBInspectable var borderWidth: Double {
        get {
            return Double(self.layer.borderWidth)
        }
        set {
            self.layer.borderWidth = CGFloat(newValue)
        }
    }
    
    /// The color of the layer's border. Defaults to opaque black. Colors created from tiled patterns are supported. Animatable.
    @IBInspectable var borderColor: UIColor? {
        get {
            return UIColor(cgColor: self.layer.borderColor!)
        }
        set {
            self.layer.borderColor = newValue?.cgColor
        }
    }
    
    
    /// The color of the shadow. Defaults to opaque black. Colors created from patterns are currently NOT supported. Animatable.
    @IBInspectable var shadowColor: UIColor? {
        get {
            return UIColor(cgColor: self.layer.shadowColor!)
        }
        set {
            self.layer.shadowColor = newValue?.cgColor
        }
    }
    
    /// The opacity of the shadow. Defaults to 0. Specifying a value outside the [0,1] range will give undefined results. Animatable.
    @IBInspectable var shadowOpacity: Float {
        get {
            return self.layer.shadowOpacity
        }
        set {
            self.layer.shadowOpacity = newValue
        }
    }
    
    /// The shadow offset. Defaults to (0, -3). Animatable.
    @IBInspectable var shadowOffset: CGSize {
        get {
            return self.layer.shadowOffset
        }
        set {
            self.layer.shadowOffset = newValue
        }
    }
    
    /// The blur radius used to create the shadow. Defaults to 3. Animatable.
    @IBInspectable var shadowRadius: Double {
        get {
            return Double(self.layer.shadowRadius)
        }
        set {
            self.layer.shadowRadius = CGFloat(newValue)
        }
    }
    
    @IBInspectable var zIndex: Int {
        get {
            return Int(self.layer.zPosition)
        }
        set {
            self.layer.zPosition = CGFloat(newValue)
        }
    }
    
    
    //MARK:- Gradient
    @IBInspectable var firstColor: UIColor = UIColor.clear {
        didSet {
           updateGradientView()
        }
    }
    @IBInspectable var secondColor: UIColor = UIColor.clear {
        didSet {
            updateGradientView()
        }
    }
    private var _degree: CGFloat = 0 {
        didSet {
            updateGradientView()
        }
    }
    @IBInspectable var degree: Int {
        get {
            return Int(self._degree)
        }
        set {
            _degree = CGFloat(newValue % 360)
        }
    }
    override open class var layerClass: AnyClass {
       get {
          return CAGradientLayer.self
       }
    }
    func updateGradientView() {
        let layer = self.layer as! CAGradientLayer
        layer.colors = [firstColor, secondColor].map{$0.cgColor}
        
        var x1:CGFloat = 0.5, y1:CGFloat = 0.5, x2: CGFloat = 0.5, y2: CGFloat = 0.5
        if self.degree <= 45 || self.degree > 315 {
            let tanA = tan(CGFloat(self.degree).toRadians())
            x1 = 1
            x2 = 0
            y1 = 0.5 + 0.5 * tanA
            y2 = 0.5 - 0.5 * tanA
        } else if self.degree <= 135 {
            let ctanA = tan(CGFloat(90 - self.degree).toRadians())
            y1 = 1
            y2 = 0
            x1 = 0.5 + 0.5 * ctanA
            x2 = 0.5 - 0.5 * ctanA
        } else if self.degree <= 225 {
            let tanA = tan(CGFloat(self.degree).toRadians())
            x1 = 0
            x2 = 1
            y1 = 0.5 - 0.5 * tanA
            y2 = 0.5 + 0.5 * tanA
        } else {
            let ctanA = tan(CGFloat(90 - self.degree).toRadians())
            y1 = 0
            y2 = 1
            x1 = 0.5 - 0.5 * ctanA
            x2 = 0.5 + 0.5 * ctanA
        }
        
        layer.startPoint = CGPoint(x: x1, y: y1)
        layer.endPoint = CGPoint (x: x2, y: y2)
    }
    
    @IBInspectable var textViewBg: UIColor = .clear {
        didSet {
            self.textInputView.backgroundColor = self.textViewBg
        }
    }
    
    private var _leftImage: UIImage? {
        didSet {
            updateView()
        }
    }
    @IBInspectable var leftImage : UIImage? {
        get {
            return _leftImage
        }
        set {
            _leftImage = newValue?.withRenderingMode(.alwaysTemplate)
        }
    }
    @IBInspectable public var leftTintColor: UIColor = .white {
        didSet {
            updateView()
        }
    }
    @IBInspectable public var leftSize: CGSize = CGSize(width: 20, height: 20) {
        didSet {
            updateView()
        }
    }
    @IBInspectable public var leftPadding: CGPoint = CGPoint(x: 10, y: 4) {
        didSet {
            updateView()
        }
    }
    
    private var _rightImage: UIImage? {
        didSet {
            updateView()
        }
    }
    @IBInspectable var rightImage: UIImage? {
        get {
            return _rightImage
        }
        set {
            _rightImage = newValue?.withRenderingMode(.alwaysTemplate)
        }
    }
    @IBInspectable public var rightTintColor: UIColor = .white {
        didSet {
            updateView()
        }
    }
    @IBInspectable public var rightSize: CGSize = CGSize(width: 20, height: 20) {
        didSet {
            updateView()
        }
    }
    @IBInspectable public var rightPadding: CGPoint = CGPoint(x: 4, y: 10) {
        didSet {
            updateView()
        }
    }
    
    
    @IBInspectable var placeholderColor: UIColor = UIColor.lightGray {
        didSet {
            attributedPlaceholder = NSAttributedString(string: placeholder != nil ? placeholder! : "", attributes: [NSAttributedString.Key.foregroundColor: placeholderColor])
        }
    }
    
    
    func updateView() {
        leftViewMode = UITextField.ViewMode.always
        if leftImage != nil {
            let leftView = UIView(frame: CGRect(x: 0, y: 0, width: leftSize.width + leftPadding.x + leftPadding.y, height: bounds.height))

            let top = (bounds.height - leftSize.height) / 2
            let imageView = UIImageView(frame: CGRect(origin: CGPoint(x: leftPadding.x, y: top), size: leftSize))
            leftView.addSubview(imageView)
            imageView.contentMode = .scaleAspectFit
            imageView.image = self.leftImage
            imageView.tintColor = self.leftTintColor
            self.leftView = leftView
        } else {
            leftView = UIView(frame: CGRect(x: 0, y: 0, width: 10, height: bounds.height))
        }

        rightViewMode = UITextField.ViewMode.always
        if rightImage != nil {
            let rightView = UIView(frame: CGRect(x: 0, y: 0, width: rightSize.width + rightPadding.x + rightPadding.y, height: bounds.height))
            
            let top = (bounds.height - rightSize.height) / 2
            let imageView = UIImageView(frame: CGRect(origin: CGPoint(x: rightPadding.x, y: top), size: rightSize))
            rightView.addSubview(imageView)
            imageView.contentMode = .scaleAspectFit
            imageView.image = self.rightImage
            imageView.tintColor = self.rightTintColor

            self.rightView = rightView
        } else {
            rightView = UIView(frame: CGRect(x: 0, y: 0, width: 10, height: bounds.height))
        }

    }
//
//    @IBInspectable var paddingLeft: CGFloat = 10 {
//        didSet {
//            padding = UIEdgeInsets(top: 0, left: paddingLeft, bottom: 0, right: paddingRight)
//        }
//    }
//    @IBInspectable var paddingRight: CGFloat = 10 {
//        didSet {
//            padding = UIEdgeInsets(top: 0, left: paddingLeft, bottom: 0, right: paddingRight)
//        }
//    }
//
//    var padding: UIEdgeInsets = UIEdgeInsets(top: 0, left: 10, bottom: 0, right: 10)
//
//    override func textRect(forBounds bounds: CGRect) -> CGRect {
//        return bounds.inset(by: padding)
//    }
//
//    override func placeholderRect(forBounds bounds: CGRect) -> CGRect {
//        return bounds.inset(by: padding)
//    }
//
//    override func editingRect(forBounds bounds: CGRect) -> CGRect {
//        return bounds.inset(by: padding)
//    }
//
}
