//
//  BaseCollectionView.swift
//  GIFT_APP
//
//  Created by Alguz on 12/9/19.
//  Copyright Â© 2019 Leo Suzin. All rights reserved.
//

import UIKit

class BaseCollectionView: UICollectionView {

    /*
    // Only override draw() if you perform custom drawing.
    // An empty implementation adversely affects performance during animation.
    override func draw(_ rect: CGRect) {
        // Drawing code
    }
    */

    override init(frame: CGRect, collectionViewLayout layout: UICollectionViewLayout) {
        super.init(frame: frame, collectionViewLayout: layout)
        setupViews()
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        setupViews()
    }
    
    func setupViews() {
        
    }
    
    /// When positive, the background of the layer will be drawn with rounded corners. Also effects the mask generated by the `masksToBounds' property. Defaults to zero. Animatable.
    @IBInspectable var cornerRadius: Double {
        get {
            return Double(self.layer.cornerRadius)
        }
        set {
            self.layer.cornerRadius = CGFloat(newValue)
        }
    }
    
    @IBInspectable var topLeft: Bool = true {
        didSet {
            updateCorners()
        }
    }

    @IBInspectable var topRight: Bool = true {
        didSet {
            updateCorners()
        }
    }

    @IBInspectable var bottomLeft: Bool = true {
        didSet {
            updateCorners()
        }
    }

    @IBInspectable var bottomRight: Bool = true {
        didSet {
            updateCorners()
        }
    }
    
    private func updateCorners() {
        var masks = CACornerMask()
        if topLeft {
            masks.insert(.layerMinXMinYCorner)
        }
        if topRight {
            masks.insert(.layerMaxXMinYCorner)
        }
        if bottomLeft {
            masks.insert(.layerMinXMaxYCorner)
        }
        if bottomRight {
            masks.insert(.layerMaxXMaxYCorner)
        }
        layer.maskedCorners = masks
    }
    
    
    /// The width of the layer's border, inset from the layer bounds. The border is composited above the layer's content and sublayers and includes the effects of the `cornerRadius' property. Defaults to zero. Animatable.
    @IBInspectable var borderWidth: Double {
        get {
            return Double(self.layer.borderWidth)
        }
        set {
            self.layer.borderWidth = CGFloat(newValue)
        }
    }
    
    /// The color of the layer's border. Defaults to opaque black. Colors created from tiled patterns are supported. Animatable.
    @IBInspectable var borderColor: UIColor? {
        get {
            return UIColor(cgColor: self.layer.borderColor!)
        }
        set {
            self.layer.borderColor = newValue?.cgColor
        }
    }
    
    
    /// The color of the shadow. Defaults to opaque black. Colors created from patterns are currently NOT supported. Animatable.
    @IBInspectable var shadowColor: UIColor? {
        get {
            return UIColor(cgColor: self.layer.shadowColor!)
        }
        set {
            self.layer.shadowColor = newValue?.cgColor
        }
    }
    
    /// The opacity of the shadow. Defaults to 0. Specifying a value outside the [0,1] range will give undefined results. Animatable.
    @IBInspectable var shadowOpacity: Float {
        get {
            return self.layer.shadowOpacity
        }
        set {
            self.layer.shadowOpacity = newValue
        }
    }
    
    /// The shadow offset. Defaults to (0, -3). Animatable.
    @IBInspectable var shadowOffset: CGSize {
        get {
            return self.layer.shadowOffset
        }
        set {
            self.layer.shadowOffset = newValue
        }
    }
    
    /// The blur radius used to create the shadow. Defaults to 3. Animatable.
    @IBInspectable var shadowRadius: Double {
        get {
            return Double(self.layer.shadowRadius)
        }
        set {
            self.layer.shadowRadius = CGFloat(newValue)
        }
    }
    
    @IBInspectable var zIndex: Int {
        get {
            return Int(self.layer.zPosition)
        }
        set {
            self.layer.zPosition = CGFloat(newValue)
        }
    }
    
    
    //MARK:- Gradient
    @IBInspectable var firstColor: UIColor = UIColor.clear {
        didSet {
           updateGradientView()
        }
    }
    @IBInspectable var secondColor: UIColor = UIColor.clear {
        didSet {
            updateGradientView()
        }
    }
    private var _degree: CGFloat = 0 {
        didSet {
            updateGradientView()
        }
    }
    @IBInspectable var degree: Int {
        get {
            return Int(self._degree)
        }
        set {
            _degree = CGFloat(newValue % 360)
        }
    }
    override open class var layerClass: AnyClass {
       get {
          return CAGradientLayer.self
       }
    }
    func updateGradientView() {
        let layer = self.layer as! CAGradientLayer
        layer.colors = [firstColor, secondColor].map{$0.cgColor}
        
        var x1:CGFloat = 0.5, y1:CGFloat = 0.5, x2: CGFloat = 0.5, y2: CGFloat = 0.5
        if self.degree <= 45 || self.degree > 315 {
            let tanA = tan(CGFloat(self.degree).toRadians())
            x1 = 1
            x2 = 0
            y1 = 0.5 + 0.5 * tanA
            y2 = 0.5 - 0.5 * tanA
        } else if self.degree <= 135 {
            let ctanA = tan(CGFloat(90 - self.degree).toRadians())
            y1 = 1
            y2 = 0
            x1 = 0.5 + 0.5 * ctanA
            x2 = 0.5 - 0.5 * ctanA
        } else if self.degree <= 225 {
            let tanA = tan(CGFloat(self.degree).toRadians())
            x1 = 0
            x2 = 1
            y1 = 0.5 - 0.5 * tanA
            y2 = 0.5 + 0.5 * tanA
        } else {
            let ctanA = tan(CGFloat(90 - self.degree).toRadians())
            y1 = 0
            y2 = 1
            x1 = 0.5 - 0.5 * ctanA
            x2 = 0.5 + 0.5 * ctanA
        }
        
        layer.startPoint = CGPoint(x: x1, y: y1)
        layer.endPoint = CGPoint (x: x2, y: y2)
    }
}
